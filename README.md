# Virtual Memory Manager Learning Tool
# Authored by: Abraham Silberschatz, Peter B. Galvin, and Greg Gagne
# Modified by: Gabriel Nathaniel Swortwood

**What is this program?**

Virtual Memory Manager, it from IT365 it uses software to handle the load to accommodate tasks for physical memory shortages. It came from the book "Operating System Concepts with Java - Eighth Edition" by Abraham Silberschatz, Peter B. Galvin, and Greg Gagne.

The classes together work to form a virtual memory simulation allowing users to perform address translation for virtual memory addresses and generate the needed statistics about the entire process of address translation.

**Why I selected it?**

The why I selected the project is more in line with how I feel as a person, memory is a precious thing to me. Both reality and in my computer, I feel having working memory is needed in day to day life. With exploring this project I began to understand more and more what it does. It is a great learning tool to practice with and learn about how memory/address translation works. I feel a bit not creative enough with my own endeavors but this project has made me feel a bit better about exploring myself on coding.

I chose this artifact to better myself as a person as understanding as to how memory works and how I can apply that logic/knowledge for a later job opportunity or even something I can work on or even share with people. As the original code is not mine, I have just altered a large portion of it.

All regards should be given to: "Abraham Silberschatz, Peter B. Galvin, and Greg Gagne."


Informal Code Review:



Artifact: IT 365: Operating Environments - Virtual Memory Manager


Reflection:

My reflection changes as the project continues onward throughout the development, here are my base reflections:

**Milestone Two:**

During the initial phase of the project, I encountered several challenges while working with Java. I had to troubleshoot various errors, which allowed me to learn more about implementing functionality and using try-catch blocks effectively. Additionally, I discovered that relying on booleans alone might not resolve certain issues. While working with floating-point assignments, I realized that they have their place, especially when handling mathematical operations, but they should be used judiciously.

As I progressed, I found that it was okay for the code to break occasionally, as it allowed me to refresh my understanding of Java fundamentals, such as data types, casting, and import functions. This experience taught me that not everything needs a complex approach; simplicity can also yield effective solutions. During the process, I made improvements to the code and discovered that some functions could be further optimized.

Overall, this phase was a valuable learning experience. I gained insights into identifying and learning from mistakes, embracing trial and error, and leveraging my foundational Java knowledge. I understood that small improvements, no matter how minor, contribute to the overall progress of the project.

# **Milestone Three:**

As the project continued, my familiarity with Java increased, and I began to recall specific language conventions, such as naming constructors similarly to the class name. However, I faced numerous challenges during this phase, including problem-solving, documenting my intent, handling errors, refactoring code for better readability, considering design patterns, understanding the existing codebase, and adhering to best practices and standards.

Understanding the project's intent posed a significant challenge since I wasn't involved in its initial development. To overcome this, I systematically analyzed various classes, such as ADDRESS and FRAME, to comprehend their functions and how they interacted with each other. Despite the challenges, I felt motivated to improve the project continuously.

Throughout this phase, I recognized that the project's complexity made me question if it was user-friendly. It pushed me to explore alternative solutions and consider multiple possibilities rather than settling for simplistic answers.

# **Milestone Four:**

The final phase presented a new set of challenges, especially when integrating the code with MongoDB. I had limited exposure to MongoDB in the past, and thus, I had to invest time in understanding its intricacies. Setting up the database required additional tools like a separate server and compass, which was a learning experience in itself.

When converting the code to a Maven-based project, I faced some initial difficulties, but I eventually resolved the issues. Despite the hurdles, I managed to improve the code's quality significantly by incorporating necessary documentation.

Overall, the project's progression and enhancements taught me valuable lessons in troubleshooting, database integration, and documentation. While there is still room for improvement, I am proud of the progress I've made in this project, and I appreciate the opportunity to tackle such a substantial task.

In summary, the iterative process of enhancing and modifying the artifact allowed me to gain a deeper understanding of Java, problem-solving, and database integration. The challenges I encountered helped me grow as a developer and reinforced the importance of continuous improvement and thoughtful design.

